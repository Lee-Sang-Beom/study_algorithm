# 다이나믹 프로그래밍 문제 조건
 # - 큰 문제를 작은 문제로 나누고, 작은 문제 답을 모아 큰 문제를 해결 가능할 때
 # - 동일한 작은 문제를 반복적으로 해결해야 할 때
     # 다이나믹은 메모리를 이용한 선형해결방식
 # 분할 정복과 다이나믹 프로그래밍은 최적부분구조를 가질때 사용가능하다.
 # 다이나믹 프로그래밍문제에서는, 동일한 각 부분문제들이 서로 영향을 미치면서 부분문제가 '중복'된다는 점이다
 # 하지만, 분할정복(퀵정렬)의 대표인 퀵 정렬에서는 한번사용된 피봇을 다시 호출하지않음.
 #이런부분에서, 부분문제의 중복에 다이나믹과 분할정복은 차이가있음

     
# 피보나치수열 : 1 1 2 3 5 8 13 21 34 55 89
# an = (an-1)+a(n-2), a1=1, a2=1

# 단순 재귀함수로 피보나치 수열을 해결하면 지수시간복잡도를 가지게 됨다.
def fibo(x): 
    if x==1 or x==2:
        return 1
    return fibo(x-1)+fibo(x-2)

print(fibo(8)) # 8번째 값은?



# top-down : 하향식방법 - 이전 계산결과를 일시적으로 기록해놓은 넓은개념
# bottom-up : 상향식 방법 - 아래쪽에서부터 작은문제를 하나씩 해결해나가면서 먼저계산했던문제 값을 활용해 다음문제에 적

# 1. top-down : o(n)
memory = [0]*100 # 계산된 결과를 memoization하기 위한 리스트 초기화

def fibo_2(x):
    if x==1 or x==2:
        return 1
    if memory[x]!=0:
        return memory[x] # 이미 계산한적있는문제면 반환
    memory[x]=fibo_2(x-1)+fibo_2(x-2)
    return memory[x]

print(fibo_2(99))


# 2. bottom_up
memory2 = [0]*100 # 계산된 결과를 memoization하기 위한 리스트 초기화
memory2[1]=1
memory2[2]=1
n=99

for i in range(3,n+1):
    memory2[i] = memory2[i-1] + memory2[i-2] # 작은문제부터 해결하고 다음문제를 해결해나가는 게 특징

print(memory2[99])
